#'
#' StaticMeasure class
#' 
#' @docType class
#' 
#' @seealso \code{\link{StaticMeasureConstructor}}
#' 
#' @name StaticMeasure-class
#' @rdname StaticMeasure-class
#' @exportClass StaticMeasure
#' 
#' @description
#' A StaticMeasure holds multilevel/multivariate data associated with an OriginPeriod.
#' 
#' @details
#' 
#' A StaticMeasure is effectively a time series, or set of time series. Because each value of a StaticMeasure
#' corresponds to an element of an OriginPeriod- which represents an interval of time- the StaticMeasure does not represent
#' an observation at a single point in time. In an insurance context, common StaticMeasures would include written or earned
#' premium, written or earned exposure, number of insured locations for a fixed duration and the like. In-force premium or 
#' in-force exposure would not constitute a StaticMeasure as this is a measure at a single point in time.
#' 
#' A StaticMeasure is so called to distinguish it from a StochasticMeasure. A StochasticMeasure also has a correspondence
#' to a single element of an OriginPeriod, but its value changes from one observation to the next. This would be the case for
#' number of claims, paid losses and the like. This would also be true for loss-sensitive premium such as exists in a retrospectively
#' rated policy.
#' 
#' A StaticMeasure object may hold more than one measure for each time period. Earned premium and policy count may both be stored
#' in a single object, for example. This is done to facilitate a multivariate approach to the loss reserving problem. Stochastic 
#' responses may depend on more than one variable.
#' 
#' \strong{Levels}
#' Each StaticMeasure may be assigned level parameters which enable multiple sets of measures to be stored in the 
#' same object. This will, in turn, facilitate construction of a hierarchical analysis model. The levels may be
#' of any arbitraty complexity, irrespective of the number of elements of the StaticMeasure object. For example, one
#' may have a single StaticMeasure which uses more than one level element: GL, prem/ops, California, for example. 
#' The object is constrained in that there must be enough levels to describe each element of the object. The constructor examples
#' should make this clear.
#' 
#' If the user does not specify level attributes, the default value of "All" is used.
#' 
#' \strong{StaticMeasure construction}
#' To construct
#' 
#' \strong{Member access}
#' Elements of a StaticMeasure object are accessed in a manner similar to those for data frames. However, a StaticMeasure has two, not
#' three dimensions. One way of thinking of this is that a StaticMeasure is a list of data frames. The indexing convention is as follows:
#' Because the "data frame" may be thought of as having rows specific by OriginPeriod and columns specified by the names of measured 
#' values, the i and i indices are used to specify these two dimensions. The third dimension is used to identify the Level. For a 
#' StochasticMeasure object, a fourth dimension is used to identify the evalution date, or development lag.
NULL

#************************************************************************************************************************
# 1. Class Definition ====
#' @export
is.StaticMeasure = function(object)
{
  is(object, "StaticMeasure")
}

checkStaticMeasure = function(object)
{
  errors = character()
  if (length(errors) == 0) TRUE else errors
}

setClass("StaticMeasure"
         , representation(OriginPeriod = "OriginPeriod"
                          , Measure = "data.frame"
                          , Level = "data.frame"
                          , .data = "data.frame")
)
#************************************************************************************************************************
# 2. Construction ====
StaticMeasure = function(OriginPeriod, Measure, Level){
  stop("You must use a specific constructor method to create a StaticMeasure object. 
       Is it possible you forgot to provide a formal argument name?")
}

setGeneric("StaticMeasure")

#' @export
setMethod("StaticMeasure", signature=c(OriginPeriod = "OriginPeriod", Measure="data.frame", Level="data.frame")
          , definition=function(OriginPeriod, Measure, Level){
            
            if (nrow(Measure) / length(OriginPeriod) != nrow(Level)){
              stop("Measure must be the product of length(OriginPeriod) and nrow(Level).")
            }
            op = new("StaticMeasure"
                     , OriginPeriod = OriginPeriod
                     , Measure = Measure
                     , Level = Level)
            op
})

#************************************************************************************************************************
# 3. Properties ====
#' @export
setMethod("length", signature(x="StaticMeasure"), definition=function(x){
  # TODO: This should reflect the total number of rows
  nrow(x@Measure)
})

setGeneric("MeasureNames", function(x){
  standardGeneric("MeasureNames")
})

#' @export
setMethod("MeasureNames", signature(x="StaticMeasure"), definition=function(x){
  colnames(x@Measure)
})

setGeneric("LevelNames", function(x){
  standardGeneric("LevelNames")
})

#' @export
setMethod("LevelNames", signature(x="StaticMeasure"), definition=function(x){
  colnames(x@Level)
})

#' @export 
setMethod("show", signature(object="StaticMeasure"), definition=function(object){
  cat("StaticMeasure object \n")
  cat("Measures:\t", paste(names(object@Measure), collapse=", "), "\n")
  cat("Levels:\t", paste(names(object@Level), collapse=", "), "\n")
  cat("Length:\t", length(object), "\n")
  cat("\nThe OriginPeriod slot is:\n")
  cat("\t\t",show(object@OriginPeriod), "\n")
})

#************************************************************************************************************************
# 4. Accessors ====
# Accessors extract from OriginPeriod, Level and Measure
#' @export 
setMethod("[", signature(x="StaticMeasure"), definition=function(x, i, j, k, ..., drop){
  
  if(missing(i)) i = NA
  if(missing(j)) j = NA
  if(missing(k)) k = NA
  
  if (any(is.na(i))) {
    i = 1:(length(x@OriginPeriod))
  }
  
  if (any(is.na(j))) j = colnames(x@Measure)
  
  if (any(is.na(k))) {
    level = data.frame(x@Level)
    measureIndex = 1:(nrow(x@Level))
  } else {
    if (is.character(k)) {
      z = as.matrix(sapply(x@Level, function(y) y %in% k))
      k = which(rowSums(z) != 0)  
    }
    
    level = data.frame(x@Level[k, ])
    measureIndex = k
  }
  
  measureIndex = (measureIndex - 1) * length(x@OriginPeriod)
  measureIndex = c(sapply(measureIndex, function(x) x + i))
  
  sm = StaticMeasure(x@OriginPeriod[i], x@Measure[measureIndex, j, drop=FALSE], level)
})

#' @export 
setMethod("[", signature(x="StaticMeasure", i="logical"), definition=function(x, i, j, k, ..., drop=TRUE){
  if(missing(j)) j = NA
  if(missing(k)) k = NA
  i = which(i)
  sm = '['(x, i, j, k, ..., drop)
  sm
})

#' @export 
setMethod("[", signature(x="StaticMeasure", i="character"), definition=function(x, i, j, k, ..., drop=TRUE){
  if(missing(j)) j = NA
  if(missing(k)) k = NA
  op = x@OriginPeriod
  i = which(op@Moniker == i)
  sm = '['(x, i, j, k, ..., drop)
  sm
})

# setMethod("[<-", signature(x = "StaticMeasure", value = "StaticMeasure"), definition=function(x, i, j, ..., value) {
# })

#' @export
setMethod("$", signature(x = "StaticMeasure"), function(x, name) {
  if (name %in% slotNames(x)){
    slot(x, name)
  } else if (name %in% MeasureNames(x)){
    x@Measure[, name]
  } else if (name %in% LevelNames(x)) {
    x@Level[, name]
  } else {
    stop("Name does not correspond to any slot, level or measure.")
  }
})
 
setMethod("$<-", signature(x = "StaticMeasure"), function(x, name, value) {
  
  if (length(name) > 1) stop("Cannot assign more than one value at a time.")
  
  if (name %in% slotNames(x)){
    stop("Slot names may not be used as value names.")
  } else if (name %in% MeasureNames(x)){
    x@Measure[name] = value
  } else if (name %in% LevelNames(x)) {
    x@Level[name] = value
  } else {
    x@Measure = cbind(x@Measure, value)
    colnames(x@Measure)[length(colnames(x@Measure))] = name
  }
  
  x
  
})

#************************************************************************************************************************
# 5. Comparison ====

#************************************************************************************************************************
# 6. Conversion ====
#' @export
setMethod("as.data.frame", signature("StaticMeasure"), function(x, ...){
  dfLevel = x@Level
  op = as.data.frame(x@OriginPeriod)
  df = merge(op, dfLevel, all=TRUE, sort=FALSE)
  df = cbind(df, x@Measure)
  df
})

setMethod("as.formula", signature(object="StaticMeasure"), definition=function(object){
  facetFormula = LevelNames(object)
  firstHalf = ceiling(length(facetFormula) / 2)
  secondHalf = (firstHalf+1):length(facetFormula)
  firstHalf = 1:firstHalf
  
  LHS = paste(LevelNames(object)[firstHalf], collapse="+")
  RHS = paste(LevelNames(object)[secondHalf], collapse="+")
  facetFormula = as.formula(paste(LHS, "~", RHS))
  
  facetFormula
})
#************************************************************************************************************************
# 7. Concatenate ====
# setMethod("rbind", signature="StaticMeasure", definition=function(..., deparse.level=1){
#   elements = list(...)
#   blnSMs = sapply(elements, is.StaticMeasure)
#   elements = elements[blnSMs]
#   
#   Levels = lapply(elements, slot, "Level")
#   Levels = try ( do.call("rbind", Levels) )
#   if (class(Levels) == "try-error") {
#     stop("StaticMeasure levels are incompatible. Levels must have the same names.")
#   } else {
#     if (nrow(unique(Levels)) != nrow(Levels)){
#       # How do we handle this? If the OriginPeriods are the same and the levels are the 
#       # same, the operation shouldn't be permitted. For now, just log that we're dealing with 
#       # the same Levels
#       equalLevels = TRUE
#     }
# 
#   }
#   
#   Levels
# #   OriginPeriod = do.call("rbind", lapply(elements, slot, "OriginPeriod"))
# #   Measure = rbind(unlist(lapply(elements, slot, "Measure")))
# #   
# #   x = StaticMeasure(OriginPeriod = OriginPeriod, Measure=Measure, Level=Level)
# #   x
# })
# 
# setMethod("c", signature(x="StaticMeasure"), definition=function(x, ...){
#   elements = list(...)
#   
# })

# Addition of a group may be done via rbind and c()
# AddGroup = function(StaticMeasure, df){
#   
# }
# Addition of a measure may be done via cbind
# AddMeasure = function(StaticMeasure, df){
#   
# }

#************************************************************************************************************************
# 8. Persistence ====

#************************************************************************************************************************
# 9. Display ====
#' @export
setMethod("plot", signature(x="StaticMeasure", y="missing"), definition = function(x, facetFormula, ...){
            
  df = as.data.frame(x)
            
  mdf = melt(df, id.vars=c("StartDate", "EndDate", "Moniker", LevelNames(x)), measure.vars=MeasureNames(x))
  
  if (missing(facetFormula)) facetFormula = as.formula(x)
  
  plt = ggplot(mdf, aes(x=Moniker, y = value, group=variable)) + geom_line() + facet_grid(facetFormula)
  plt
            
})
