#'
Triangle = function(OriginPeriods
                    , DevelopmentPeriods
                    , Groups
                    , StaticMeasures
                    , StochasticMeasures
                    , TriangleName
                    , OriginPeriodType
                    , df
                    , ...){
  tri = new("Triangle"
            , TriangleData = data.frame()
            , TriangleName = character()
            , OriginPeriodType = character()
            , DevelopmentInterval = period(0)
            , StaticMeasures = character()
            , StochasticMeasures = character()
            , Groups = character())
  
  tri
}
setGeneric("Triangle")


setMethod(f="Triangle", signature(OriginPeriods="POSIXct"), definition = function(OriginPeriods){
  df = data.frame(OriginPeriods)
  tri = new("Triangle"
            , TriangleData = df
            , TriangleName = character()
            , OriginPeriodType = character()
            , DevelopmentInterval = period(0)
            , StaticMeasures = character()
            , StochasticMeasures = character()
            , Groups = character())
  
  tri
})

setMethod("Triangle", signature(df="data.frame"), function(x){
  
})


setMethod(f = "Triangle"
          , signature(x="Triangle", y="missing")
          , definition = function(x, ...){
            plotTriangle(objTriangle = x, ...)
          })

#' Create a Triangle object.
#' @param TriangleData A dataframe 
#' @param OriginPeriods The name of the column in the TriangleData which holds the origin period.
#' @param DevelopmentLags The column which holds the development lags.
#' @param OriginEnd If the OriginPeriods argument refers to the start date of an origin period, this column holds the end dates.
#' @param OriginLength If origin period is not an interval, this is used to construct the origin period.
#' @param StartDay If origin period is not an interval, this is used to construct the origin period.
#' @param StartMonth If origin period is not an interval, this is used to construct the origin period.
#' @param DevelopmentPeriod If DevelopmentLags is not a period object, this is used to contruct DevelopmentLags.
#' @param EvaluationDates A vector of dates corresponding to the data in TriangleData.
#' @param OriginPeriodType A character value describing the type of origin period.
#' @param TriangleName A character value used to refer to the Triangle object.
#' @param StaticMeasures A character vector which names the static measures in the Triangle object.
#' @param StochasticMeasures A character vector which names the stochastic measures in the Triangle object.
#' @param Groups A character vector which names the column which contains grouping data.
#' @param Cumulative Boolean indicating if the stochastic measures are cumulative or incremental.
#' @param Verbose Boolean indicating whether or not warnings should be displayed.
#' 
#' @export newTriangle
#' @include Triangle.R
#' @include TriangleAdjustMeasures.R
#' @include CreateDevelopmentLags.R
#' @include CreateEvaluationDates.R
#' @include CreateOriginPeriods.R
#' 
# User-friendly constructor
newTriangle = function(TriangleData
                       , OriginPeriods = NULL
                       , DevelopmentLags = NULL
                       , OriginEnd = NULL
                       , OriginLength = years(1)
                       , StartDay = 1
                       , StartMonth = 1
                       , DevelopmentPeriod = months(1)
                       , EvaluationDates = NULL
                       , OriginPeriodType = "Accident Year"
                       , TriangleName = NULL
                       , StaticMeasures = NULL
                       , StochasticMeasures = NULL
                       , Groups = NULL
                       , Cumulative = TRUE
                       , Verbose = TRUE)
{
  
  # 1. Construct proper temporal dimensions
  # 2. Gather group and measure names (?)
  # 3. Establish stochastic measures
  arguments <- as.list(match.call())
  
  OriginPeriods = eval(arguments$OriginPeriods, TriangleData)
  if(is.null(OriginPeriods)) stop ("No origin period was specified.")
  
  if (!is.interval(OriginPeriods)) {
    OriginPeriods = CreateOriginPeriods(OriginPeriods, OriginEnd, OriginLength, StartDay, StartMonth, Verbose)
  }
  
  DevelopmentLags = eval(arguments$DevelopmentLags, TriangleData)
  if(is.null(DevelopmentLags)) stop ("No development lag information was provided.")
  
  if (!is.period(DevelopmentLags)){
    DevelopmentLags = CreateDevelopmentLags(DevelopmentLags, DevelopmentPeriod, EvaluationDates, OriginPeriods, Verbose)
  }
  
  CommonDevInterval = DevelopmentLags[order(DevelopmentLags)]
  CommonDevInterval = CommonDevInterval[1]
  if(Verbose){
    DevInteger = DevelopmentLags / CommonDevInterval  
  } else {
    DevInteger = suppressMessages(DevelopmentLags / CommonDevInterval)
  }
  
  if(is.null(EvaluationDates)) {
    EvaluationDates = CreateEvaluationDates(OriginPeriods, DevelopmentLags)
  } else {
    # Throw a warning if the evaluation dates which were passed in are not consistent with what they ought to be.
  }
  
  # It's possible that the user has fed data with overlap. 
  # Annual data with two start dates in the same year and annual development period, zB.
  # I might decide to check for this and throw a warning, but for now, I'll just blame the user.
  
  dfNewTriangleData = data.frame(OriginPeriod = OriginPeriods
                                 , DevelopmentLag = DevelopmentLags
                                 , EvaluationDate = EvaluationDates
                                 , DevInteger = DevInteger)
  
  dfNewTriangleData$OriginPeriodStart = int_start(dfNewTriangleData$OriginPeriod)
  dfNewTriangleData$OriginPeriodEnd = int_end(dfNewTriangleData$OriginPeriod)
  
  dfNewTriangleData$CalendarPeriodStart = dfNewTriangleData$EvaluationDate - CommonDevInterval + days(1)
  dfNewTriangleData$CalendarPeriodEnd = dfNewTriangleData$EvaluationDate 
  dfNewTriangleData$CalendarPeriod = with(dfNewTriangleData, new_interval(CalendarPeriodStart, CalendarPeriodEnd))
  
  if (is.null(Groups))
  {
    dfNewTriangleData$Group = "All"
    Groups = "Group"
  } else {
    dfNewTriangleData = cbind(dfNewTriangleData, TriangleData[Groups])
  }
  
  if (!is.null(StaticMeasures)) {
    dfNewTriangleData = cbind(dfNewTriangleData, TriangleData[StaticMeasures])
  } else {
    StaticMeasures = ""
  }
  
  if (is.null(StochasticMeasures)) stop ("You've not supplied any stochastic measures for this triangle. Idiot.")
  
  dfStochasticMeasures = TriangleData[StochasticMeasures]
  stochasticMeasureNames = FormMeasureNames(dfStochasticMeasures, Cumulative)
  names(dfStochasticMeasures) = stochasticMeasureNames
  
  dfNewTriangleData = cbind(dfNewTriangleData, dfStochasticMeasures) 
  
  if(Cumulative) {
    dfNewTriangleData = CreateIncrementals(dfNewTriangleData, stochasticMeasureNames, Groups)
    stochasticMeasureNames = c(stochasticMeasureNames, gsub("Cumulative", "Incremental", stochasticMeasureNames))
  } else {
    dfNewTriangleData = CreateCumulative(dfNewTriangleData, stochasticMeasureNames, Groups)
    stochasticMeasureNames = c(stochasticMeasureNames, gsub("Incremental","Cumulative", stochasticMeasureNames))
  }
  
  dfNewTriangleData = CreatePriors(dfNewTriangleData, stochasticMeasureNames, Groups)
  
  if (is.null(TriangleName)) TriangleName = ""
  
  row.names(dfNewTriangleData) = NULL
  
  tri = new("Triangle"
            , TriangleData = dfNewTriangleData
            , TriangleName = TriangleName
            , OriginPeriodType = OriginPeriodType
            , DevelopmentInterval = CommonDevInterval
            , StaticMeasures = StaticMeasures
            , StochasticMeasures = CleanMeasureNames(stochasticMeasureNames)
            , Groups = Groups)
  
  tri
}